(** IEC 61131 **)

(* Standard function with template type *)

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION ABS_SINT : INT
VAR_INPUT
   IN1: SINT; 
END_VAR
   IF IN1 >= 0 THEN 
      ABS_SINT := IN1;
   ELSE
      ABS_SINT := -IN1;
   END_IF   
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION ABS_INT : INT
VAR_INPUT
   IN1: INT;
END_VAR
   IF IN1 >= 0 THEN 
      ABS_INT := IN1;
   ELSE
      ABS_INT := -IN1;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION ABS_DINT : DINT
VAR_INPUT
   IN1: DINT;
END_VAR
   IF IN1 >= 0 THEN 
      ABS_DINT := IN1;
   ELSE
      ABS_DINT := -IN1;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION ABS_REAL : REAL
VAR_INPUT
   IN1: REAL;
END_VAR
   IF IN1 >= 0.0 THEN 
      ABS_REAL := IN1;
   ELSE
      ABS_REAL := -IN1;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_BYTE : BYTE
VAR_INPUT
   IN1, IN2: BYTE;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_BYTE := IN1;
   ELSE 
      MAX_BYTE := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_INT : INT
VAR_INPUT
   IN1, IN2: INT;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_INT := IN1;
   ELSE 
      MAX_INT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_UINT : UINT
VAR_INPUT
   IN1, IN2: UINT;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_UINT := IN1;
   ELSE 
      MAX_UINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_USINT : USINT
VAR_INPUT
   IN1, IN2: USINT;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_USINT := IN1;
   ELSE 
      MAX_USINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_DINT : DINT
VAR_INPUT
   IN1, IN2: DINT;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_DINT := IN1;
   ELSE 
      MAX_DINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_TIME : TIME
VAR_INPUT
   IN1, IN2: TIME;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_TIME := IN1;
   ELSE 
      MAX_TIME := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MAX_REAL : REAL
VAR_INPUT
   IN1, IN2: REAL;
END_VAR
   IF IN1 >= IN2 THEN
      MAX_REAL := IN1;
   ELSE 
      MAX_REAL := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_BYTE : BYTE
VAR_INPUT
   IN1, IN2: BYTE;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_BYTE := IN1;
   ELSE 
      MIN_BYTE := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_INT : INT
VAR_INPUT
   IN1, IN2: INT;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_INT := IN1;
   ELSE 
      MIN_INT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_UINT : UINT
VAR_INPUT
   IN1, IN2: UINT;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_UINT := IN1;
   ELSE 
      MIN_UINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_USINT : USINT
VAR_INPUT
   IN1, IN2: USINT;
END_VAR
   IF IN1 >= IN2 THEN
      MIN_USINT := IN1;
   ELSE 
      MIN_USINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_DINT : DINT
VAR_INPUT
   IN1, IN2: DINT;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_DINT := IN1;
   ELSE 
      MIN_DINT := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_TIME : TIME
VAR_INPUT
   IN1, IN2: TIME;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_TIME := IN1;
   ELSE 
      MIN_TIME := IN2;
   END_IF
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION MIN_REAL : REAL
VAR_INPUT
   IN1, IN2: REAL;
END_VAR
   IF IN1 <= IN2 THEN
      MIN_REAL := IN1;
   ELSE 
      MIN_REAL := IN2;
   END_IF
END_FUNCTION

FUNCTION ROL_BYTE : BYTE
VAR_INPUT
   IN: BYTE;
   N: DINT;
END_VAR
   ROL_BYTE := UNKNOWN_BYTE();
END_FUNCTION

FUNCTION ROL_WORD : WORD
VAR_INPUT
   IN: WORD;
   N: DINT;
END_VAR
   ROL_WORD := UNKNOWN_WORD();
END_FUNCTION

FUNCTION ROL_INT : INT
VAR_INPUT
   IN: INT;
   N: DINT;
END_VAR
   ROL_INT := UNKNOWN_INT();
END_FUNCTION

FUNCTION ROL_DWORD : DWORD
VAR_INPUT
   IN: DWORD;
   N: DINT;
END_VAR
   ROL_DWORD := UNKNOWN_DWORD();
END_FUNCTION

FUNCTION ROR_BYTE : BYTE
VAR_INPUT
   IN: BYTE;
   N: DINT;
END_VAR
   ROR_BYTE := UNKNOWN_BYTE();
END_FUNCTION

FUNCTION ROR_WORD : WORD
VAR_INPUT
   IN: WORD;
   N: DINT;
END_VAR
   ROR_WORD := UNKNOWN_WORD();
END_FUNCTION

FUNCTION ROR_INT : INT
VAR_INPUT
   IN: INT;
   N: DINT;
END_VAR
   ROR_INT := UNKNOWN_INT();
END_FUNCTION

FUNCTION ROR_DWORD : DWORD
VAR_INPUT
   IN: DWORD;
   N: DINT;
END_VAR
   ROR_DWORD := UNKNOWN_DWORD();
END_FUNCTION

FUNCTION SHL_BYTE : BYTE
VAR_INPUT
   IN: BYTE;
   N: DINT;
END_VAR
   SHL_BYTE := UNKNOWN_BYTE();
END_FUNCTION

FUNCTION SHL_WORD : WORD
VAR_INPUT
   IN: WORD;
   N: DINT;
END_VAR
   SHL_WORD := UNKNOWN_WORD();
END_FUNCTION

FUNCTION SHL_DWORD : DWORD
VAR_INPUT
   IN: DWORD;
   N: DINT;
END_VAR
   SHL_DWORD := UNKNOWN_DWORD();
END_FUNCTION

FUNCTION SHL_INT : INT
VAR_INPUT
   IN: INT;
   N: DINT;
END_VAR
   SHL_INT := UNKNOWN_INT();
END_FUNCTION

FUNCTION SHL_UINT : UINT
VAR_INPUT
   IN: UINT;
   N: DINT;
END_VAR
   SHL_UINT := UNKNOWN_UINT();
END_FUNCTION
   
FUNCTION SHR_BYTE : BYTE
VAR_INPUT
   IN: BYTE;
   N: DINT;
END_VAR
   SHR_BYTE := UNKNOWN_BYTE();
END_FUNCTION

FUNCTION SHR_WORD : WORD
VAR_INPUT
   IN: WORD;
   N: DINT;
END_VAR
   SHR_WORD := UNKNOWN_WORD();
END_FUNCTION

FUNCTION SHR_DWORD : DWORD
VAR_INPUT
   IN: DWORD;
   N: DINT;
END_VAR
   SHR_DWORD := UNKNOWN_DWORD();
END_FUNCTION

FUNCTION SHR_INT : BYTE
VAR_INPUT
   IN: INT;
   N: DINT;
END_VAR
   SHR_INT := UNKNOWN_INT();
END_FUNCTION

FUNCTION SHR_UINT : UINT
VAR_INPUT
   IN: UINT;
   N: DINT;
END_VAR
   SHR_UINT := UNKNOWN_UINT();
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION UINT_TO_BOOL : BOOL
VAR_INPUT
   IN: UINT;
END_VAR
   IF IN=0 THEN
     UINT_TO_BOOL := FALSE;
   ELSE
     UINT_TO_BOOL := TRUE;
   END_IF;
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION INT_TO_BOOL : BOOL
VAR_INPUT
   IN: INT;
END_VAR
   IF IN=0 THEN
     INT_TO_BOOL := FALSE;
   ELSE
     INT_TO_BOOL := TRUE;
   END_IF;
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION DINT_TO_BOOL : BOOL
VAR_INPUT
   IN: DINT;
END_VAR
   IF IN=0 THEN
     DINT_TO_BOOL := FALSE;
   ELSE
     DINT_TO_BOOL := TRUE;
   END_IF;
END_FUNCTION

FUNCTION DT_TO_TOD : TOD
VAR_INPUT
   IN: DT;
END_VAR
   DT_TO_TOD := UNKNOWN_TOD();
END_FUNCTION


(* Trigonometry *)

FUNCTION ASIN : REAL
VAR_INPUT
   A: REAL;
END_VAR
ASIN := UNKNOWN_REAL();
END_FUNCTION

FUNCTION ACOS : REAL
VAR_INPUT
   A: REAL;
END_VAR
ACOS := UNKNOWN_REAL();
END_FUNCTION

FUNCTION ATAN2 : REAL
VAR_INPUT
   A, B: REAL;
END_VAR
ATAN2 := UNKNOWN_REAL();
END_FUNCTION

{@ARCADE CONTEXT-SENSITIVE:true}
FUNCTION EXPT : REAL
VAR_INPUT
   IN1, IN2: REAL;
END_VAR
  IF IN2 = 2.0 THEN
    EXPT := IN1 * IN1;
  ELSIF IN2 = 0.5 THEN
    EXPT := SQRT(IN1);
  ELSE
    EXPT := UNKNOWN_REAL();
  END_IF
END_FUNCTION

(* Timer *)

FUNCTION_BLOCK TPX
VAR_INPUT
  IN : BOOL;
  PT : TIME;
END_VAR
VAR
  running : BOOL;
END_VAR
VAR_TEMP
    timeout : BOOL;
END_VAR
VAR_OUTPUT
  Q : BOOL;
  ET : TIME;
END_VAR

  timeout := UNKNOWN_BOOL();
  IF IN AND NOT running AND NOT Q THEN
    Q := TRUE;
  ELSIF Q THEN
    Q := timeout;
  END_IF
  running := IN;
  ET := UNKNOWN_TIME();
  
END_FUNCTION_BLOCK

FUNCTION_BLOCK TONX
VAR_INPUT
  IN : BOOL;
  PT : TIME;
END_VAR
VAR
  running : BOOL;
END_VAR
VAR_TEMP
    timeout : BOOL;
END_VAR
VAR_OUTPUT
  Q : BOOL;
  ET : TIME;
END_VAR

  timeout := UNKNOWN_BOOL();
  
  IF NOT IN THEN
    Q := FALSE;
    running := FALSE;
  ELSIF NOT running AND NOT Q THEN
    running := TRUE;
  ELSIF running AND NOT Q THEN
    Q := timeout;
    running := NOT Q;
  END_IF
  
  ET := UNKNOWN_TIME();
END_FUNCTION_BLOCK

FUNCTION_BLOCK TOFX
VAR_INPUT
  IN : BOOL;
  PT : TIME;
END_VAR
VAR
  running : BOOL;
END_VAR
VAR_TEMP
    timeout : BOOL;
END_VAR
VAR_OUTPUT
  Q : BOOL;
  ET : TIME;
END_VAR

  timeout := UNKNOWN_BOOL();
  
  IF IN THEN
    running := FALSE;
    Q := TRUE;
  ELSIF NOT running AND Q THEN
    running := TRUE;
  ELSIF running AND Q THEN
    Q := NOT timeout;
    running := Q;
  END_IF
  
  ET := UNKNOWN_TIME();
END_FUNCTION_BLOCK


(* String Functions *)

FUNCTION EQ_STRING : BOOL
VAR_INPUT
	IN1, IN2 : STRING;
END_VAR
EQ_STRING := UNKNOWN_BOOL();
END_FUNCTION

FUNCTION GE_STRING : BOOL
VAR_INPUT
	IN1, IN2 : STRING;
END_VAR
GE_STRING := UNKNOWN_BOOL();
END_FUNCTION

FUNCTION GT_STRING : BOOL
VAR_INPUT
	IN1, IN2 : STRING;
END_VAR
GT_STRING := UNKNOWN_BOOL();
END_FUNCTION

FUNCTION MID : STRING
VAR_INPUT
	A : STRING;
	POS : INT;
	LENGTH : INT;
END_VAR
MID := '';
END_FUNCTION

FUNCTION REPLACE : STRING
VAR_INPUT
	IN1 : STRING;
	IN2 : STRING; // CHAR?
	L, P : INT;
END_VAR
REPLACE := '';
END_FUNCTION

FUNCTION FIND : INT
VAR_INPUT
	IN1 : STRING;
	IN2 : STRING; // CHAR?
END_VAR
FIND := UNKNOWN_INT();
END_FUNCTION

FUNCTION CONCAT : STRING
VAR_INPUT
	String1, String2 : STRING;
END_VAR
CONCAT := String1+String2;
END_FUNCTION

{@UNCHECKED POSTCONDITION LEN >= 0}
FUNCTION LEN : INT
VAR_INPUT
	A : STRING;
END_VAR
LEN := UNKNOWN_INT();
END_FUNCTION

FUNCTION LEFT : STRING
VAR_INPUT
	Str : STRING;
	Len : INT;
END_VAR
LEFT := '';
END_FUNCTION

FUNCTION RIGHT : STRING
VAR_INPUT
	Str : STRING;
	Len : INT;
END_VAR
RIGHT := '';
END_FUNCTION

FUNCTION DATE_AND_TIME_TO_STRING : STRING
VAR_INPUT
	A : DATE_AND_TIME;
END_VAR
DATE_AND_TIME_TO_STRING := '';
END_FUNCTION

FUNCTION TOD_TO_STRING : STRING
VAR_INPUT
	A : TOD;
END_VAR
TOD_TO_STRING := '';
END_FUNCTION


FUNCTION UINT_TO_STRING : STRING
VAR_INPUT
	A : DINT;
END_VAR
UINT_TO_STRING := '';
END_FUNCTION

FUNCTION DINT_TO_STRING : STRING
VAR_INPUT
	A : DINT;
END_VAR
DINT_TO_STRING := '';
END_FUNCTION

FUNCTION BOOL_TO_STRING : STRING
VAR_INPUT
	A : BOOL;
END_VAR
IF A THEN
  BOOL_TO_STRING := 'TRUE';
ELSE
  BOOL_TO_STRING := 'FALSE';
END_IF;
END_FUNCTION

FUNCTION DWORD_TO_STRING : STRING
VAR_INPUT
	A : INT;
END_VAR
DWORD_TO_STRING := '';
END_FUNCTION

FUNCTION INT_TO_STRING : STRING
VAR_INPUT
	A : INT;
END_VAR
INT_TO_STRING := '';
END_FUNCTION

FUNCTION REAL_TO_STRING : STRING
VAR_INPUT
	A : REAL;
END_VAR
REAL_TO_STRING := '';
END_FUNCTION

FUNCTION STRING_TO_UINT : DINT
VAR_INPUT
	IN : STRING;
END_VAR
STRING_TO_UINT := UNKNOWN_UINT();
END_FUNCTION

FUNCTION STRING_TO_DINT : DINT
VAR_INPUT
	IN : STRING;
END_VAR
STRING_TO_DINT := UNKNOWN_DINT();
END_FUNCTION

FUNCTION STRING_TO_DATE_AND_TIME: DATE_AND_TIME
VAR_INPUT
	IN : STRING;
END_VAR
STRING_TO_DATE_AND_TIME := UNKNOWN_DT();
END_FUNCTION

FUNCTION STRING_TO_INT : INT
VAR_INPUT
	IN : STRING;
END_VAR
STRING_TO_INT := UNKNOWN_INT();
END_FUNCTION

FUNCTION STRING_TO_REAL : REAL
VAR_INPUT
	IN : STRING;
END_VAR
STRING_TO_REAL := UNKNOWN_REAL();
END_FUNCTION

(* STD FUNCTION BLOCKS *)

FUNCTION_BLOCK R_TRIG
VAR_INPUT
   CLK: BOOL;
END_VAR
VAR_OUTPUT
   Q: BOOL;
END_VAR
VAR
   M: BOOL;
END_VAR
Q := CLK AND NOT M;
M := CLK;
END_FUNCTION_BLOCK

FUNCTION_BLOCK F_TRIG
VAR_INPUT
   CLK: BOOL;
END_VAR
VAR_OUTPUT
   Q: BOOL;
END_VAR
VAR
   M: BOOL;
END_VAR
Q := NOT CLK AND M;
M := CLK;
END_FUNCTION_BLOCK

FUNCTION_BLOCK SR
VAR_INPUT
   SET1, RESET : BOOL;
END_VAR
VAR_OUTPUT
   Q1: BOOL;
END_VAR
Q1 := (NOT RESET AND Q1) OR SET1;
END_FUNCTION_BLOCK

FUNCTION_BLOCK RS
VAR_INPUT
   S, RESET1: BOOL;
END_VAR
VAR_OUTPUT
   Q1: BOOL;
END_VAR
Q1 := NOT RESET1 AND (Q1 OR S);
END_FUNCTION_BLOCK

FUNCTION_BLOCK SEMA
 VAR_INPUT
    CLAIM, RELEASE: BOOL;
 END_VAR
 VAR_OUTPUT
    BUSY: BOOL;
 END_VAR
 VAR
    X: BOOL := FALSE;
 END_VAR
BUSY := X;
IF CLAIM THEN
   X := TRUE;
ELSIF RELEASE THEN
   BUSY := FALSE;
   X := FALSE;
END_IF
END_FUNCTION_BLOCK

(* CoDeSys *)

TYPE
   SAFEBOOL: BOOL;
END_TYPE

(* IO-Types *)

TYPE
   BoolIO:
     STRUCT
       Value: BOOL;
       IOValue: BOOL;
       Forced: BOOL;
       Status: DWORD;
     END_STRUCT;
END_TYPE

FUNCTION_BLOCK SFC_ACTION_CONTROL
VAR_INPUT
    N, R, S, L , D, P , P0, P1, SD, DS, SL : BOOL;
    T : TIME;
END_VAR
VAR_OUTPUT
    Q, A : BOOL;
END_VAR
VAR
    S_FF, SD_FF, DS_FF, SL_FF : RS;
    L_TMR, D_TMR, SD_TMR, DS_TMR, SL_TMR : TON;
    P_TRIG, P1_TRIG : R_TRIG;
    P0_TRIG, Q_TRIG : F_TRIG;
END_VAR;

S_FF(S := S, RESET1 := R);

L_TMR(IN := L, PT := T);

D_TMR(IN := D, PT := T);

P_TRIG(CLK := P);

SD_FF(S := SD, RESET1 := R);
SD_TMR(IN := SD_FF.Q1, PT := T);

DS_TMR(IN := DS, PT := T);
DS_FF(S := DS_TMR.Q, RESET1 := R);

SL_FF(S := SL, RESET1 := R);
SL_TMR(IN := SL_FF.Q1, PT := T);

Q := NOT R AND
        (N OR
        S_FF.Q1 OR
        (L AND NOT L_TMR.Q) OR
        D_TMR.Q OR
        P_TRIG.Q OR
        SD_TMR.Q OR
        DS_FF.Q1 OR
        (SL_FF.Q1 AND NOT SL_TMR.Q));

P1_TRIG(CLK := P1);
P0_TRIG(CLK := P0);
Q_TRIG(CLK := Q);

A := Q OR Q_TRIG.Q OR P1_TRIG.Q OR P0_TRIG.Q;

END_FUNCTION_BLOCK

FUNCTION_BLOCK SFC_ACTION_CONTROL_X
VAR_INPUT
    N, R, S, L , D, P , P0, P1, SD, DS, SL : BOOL;
    T : TIME;
END_VAR
VAR_OUTPUT
    Q, A : BOOL;
END_VAR
VAR
    S_FF, SD_FF, DS_FF, SL_FF : RS;
    L_TMR, D_TMR, SD_TMR, DS_TMR, SL_TMR : TONX;
    P_TRIG, P1_TRIG : R_TRIG;
    P0_TRIG, Q_TRIG : F_TRIG;
END_VAR;

S_FF(S := S, RESET1 := R);

L_TMR(IN := L, PT := T);

D_TMR(IN := D, PT := T);

P_TRIG(CLK := P);

SD_FF(S := SD, RESET1 := R);
SD_TMR(IN := SD_FF.Q1, PT := T);

DS_TMR(IN := DS, PT := T);
DS_FF(S := DS_TMR.Q, RESET1 := R);

SL_FF(S := SL, RESET1 := R);
SL_TMR(IN := SL_FF.Q1, PT := T);

Q := NOT R AND
        (N OR
        S_FF.Q1 OR
        (L AND NOT L_TMR.Q) OR
        D_TMR.Q OR
        P_TRIG.Q OR
        SD_TMR.Q OR
        DS_FF.Q1 OR
        (SL_FF.Q1 AND NOT SL_TMR.Q));

P1_TRIG(CLK := P1);
P0_TRIG(CLK := P0);
Q_TRIG(CLK := Q);

A := Q OR Q_TRIG.Q OR P1_TRIG.Q OR P0_TRIG.Q;

END_FUNCTION_BLOCK

FUNCTION_BLOCK SFC_ACTION_CONTROL_SIMPLE
VAR_INPUT
    N, R, S, L , D, P , P0, P1, SD, DS, SL : BOOL;
    T: TIME;
END_VAR
VAR_OUTPUT
    Q :BOOL;
END_VAR
VAR
    S_FF, SD_FF, DS_FF, SL_FF: RS;
    L_TMR, D_TMR, SD_TMR, DS_TMR, SL_TMR: TON;
    P_TRIG, P1_TRIG : R_TRIG;
    P0_TRIG : F_TRIG;
END_VAR;

S_FF(S := S, RESET1 := R);

L_TMR(IN := L, PT := T);

D_TMR(IN := D, PT := T);

P_TRIG(CLK := P);

SD_FF(S := SD, RESET1 := R);
SD_TMR(IN := SD_FF.Q1, PT := T);

DS_TMR(IN := DS, PT := T);
DS_FF(S := DS_TMR.Q, RESET1 := R);

SL_FF(S := SL, RESET1 := R);
SL_TMR(IN := SL_FF.Q1, PT := T);

P1_TRIG(CLK := P1);
P0_TRIG(CLK := P0);

Q := NOT R AND
        (N OR
        S_FF.Q1 OR
        (L AND NOT L_TMR.Q) OR
        D_TMR.Q OR
        P_TRIG.Q OR
        SD_TMR.Q OR
        DS_FF.Q1 OR
        (SL_FF.Q1 AND NOT SL_TMR.Q) OR
        P0_TRIG.Q OR
        P1_TRIG.Q);

END_FUNCTION_BLOCK
